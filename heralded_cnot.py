import numpy as np
import bosonic
import matplotlib.pyplot as plt


def imperfect_cnot_gate(rel_error=0):
    """
    A helper function giving the single-qubit unitary transformation fed into bosonic for simulating a photonic CNOT
   gate.
    :param rel_error: error relative to the power splitting ratio of a single MZI
    :return: a 7-by-7 array representing a unitary transformation on a single photon passing through a
      photonic CNOT gate network
    """
    r_ideal = np.sqrt([0, 0.227, 1 / 2, 1 / 2, 0.227, 1 / 2, 0.243, 1 / 2])
    r = [np.random.normal(loc=r_ideal[i], scale=rel_error * np.sqrt(r_ideal[i])) for i in range(len(r_ideal))]

    for k in range(len(r)):
        if r[k] < 0 or r[k] >= 1:
            while r[k] < 0 or r[k] >= 1:
                r[k] = np.random.normal(loc=r_ideal[k], scale=rel_error * np.sqrt(r_ideal[k]))
            # print(r[k])
    t = np.sqrt([1 - r[i] ** 2 for i in range(len(r))])

    gate = np.array([[1, 0, 0, 0, 0, 0, 0],
                     # c0
                     [0, r[1], -r[2] * t[1], -r[3] * t[2] * t[1], t[3] * t[2] * t[1], 0, 0],
                     # |1>
                     [0, -t[1] * r[5], -r[2] * r[1] * r[5] - t[2] * r[4] * t[5],
                      -r[3] * t[2] * r[1] * r[5] + r[3] * r[2] * r[4] * t[5],
                      +t[3] * t[2] * r[1] * r[5] - t[3] * r[2] * r[4] * t[5], t[4] * t[5], 0],
                     # c1
                     [0, -t[1] * t[5] * t[6] * t[7],
                      r[2] * r[1] * t[5] * t[6] * t[7] - t[2] * r[4] * r[5] * t[6] * t[7],
                      -r[3] * r[2] * r[4] * r[5] * t[6] * t[7] - r[3] * t[2] * r[1] * t[5] * t[6] * t[7] + t[3] * r[7],
                      t[3] * t[2] * r[1] * t[5] * t[6] * t[7] + r[3] * r[7] + t[3] * r[2] * r[4] * r[5] * t[6] * t[7],
                      -t[4] * r[5] * t[6] * t[7], -r[6] * t[7]],
                     # t1
                     [0, t[1] * t[5] * t[6] * r[7], r[2] * r[1] * t[5] * t[6] * r[7] - t[2] * r[4] * r[5] * t[6] * r[7],
                      +r[3] * t[2] * r[1] * t[5] * t[6] * r[7] + r[3] * r[2] * r[4] * r[5] * t[6] * r[7] + t[3] * t[7],
                      -t[3] * t[2] * r[1] * t[5] * t[6] * r[7] - t[3] * r[2] * r[4] * r[5] * t[6] * r[7] + r[3] * t[7],
                      t[4] * r[5] * t[6] * r[7], r[6] * r[7]],
                     # t0
                     [0, 0, t[2] * t[4], -r[3] * r[2] * t[4], t[3] * r[2] * t[4], r[4], 0],
                     # |1>
                     [0, t[1] * t[5] * r[6], r[2] * r[1] * t[5] * r[6] - t[2] * r[4] * r[5] * r[6],
                      r[3] * r[2] * r[4] * r[5] * r[6] + r[3] * t[2] * r[1] * t[5] * r[6],
                      -t[3] * t[2] * r[1] * t[5] * r[6] - t[3] * r[2] * r[4] * r[5] * r[6],
                      t[4] * r[5] * r[6], -t[6]]])
    # |0>
    return gate


def mzi_unitary(r=0, phi=0):
    """
    Generate the 2-mode unitary matrix representing an MZI device.
    :param r: "reflectivity" equivalent for the power splitting between the output ports, real number between 0 and 1. 
      Ex. r = 0 -> U = [[0, 1], [1, 0]].
    :param phi: phase offset between the output ports, can
    :return: 
    """
    assert isinstance(r, float) or isinstance(r, int) and 0 < r < 1, 'r must be real; 0 < r < 1'
    theta = 2 * np.arcsin(r)
    return -1j / 2 * np.array([[np.exp(1j * phi / 2), 0], [0, np.exp(-1j * phi / 2)]]) @ np.array([[1, 1j], [1j, 1]]) \
           @ np.array([[np.exp(1j * theta / 2), 0], [0, np.exp(1j * -theta / 2)]]) @ np.array([[1, 1j], [1j, 1]])


# TODO: Fix: currently incorrect probabilities
def imperfect_cnot_gate_general(phase_error=0.0):
    # get reflectivity unitaries assuming a normal distribution for phase tuning error
    # used base-1 indexing (probably should change)
    phi_ideal = [np.pi / 2, np.pi / 2, -2.14838, 2.14838, np.pi / 2, 2.11064, 0, 0, np.pi / 2, 0, 0]
    phi_imperfect = [np.random.normal(loc=phase, scale=phase_error) for phase in phi_ideal]
    u = np.array([mzi_unitary(r=np.sin(phi_imp / 2), phi=0) for phi_imp in phi_imperfect])

    gate = np.array([
        [1, 0, 0, 0, 0, 0, 0],  # c0 ports 0-6

        [0, u[2, 0, 0], u[1, 0, 0] * u[2, 0, 1], u[0, 0, 0] * u[1, 0, 1] * u[2, 0, 1],  # a1 ports 0-3
         u[0, 0, 1] * u[1, 0, 1] * u[2, 0, 1], 0, 0],  # a1 ports 4-6

        [0, u[2, 1, 0] * u[4, 0, 0],  # c1 ports 0-1
         u[1, 0, 0] * u[2, 1, 1] * u[4, 0, 0] + u[1, 1, 0] * u[3, 0, 0] * u[4, 0, 1],  # c1 port 2
         (u[0, 0, 0] * (u[1, 0, 1] * u[2, 1, 1] * u[4, 0, 0] + u[1, 1, 1] * u[3, 0, 0] * u[4, 0, 1])  # c1 port 3 ...
          + u[0, 1, 0] * u[7, 0, 0] * u[3, 0, 1] * u[4, 0, 1]),  # c1 port 3
         (u[0, 0, 1] * (u[1, 0, 1] * u[2, 1, 1] * u[4, 0, 0] + u[1, 1, 1] * u[3, 0, 0] * u[4, 0, 1])  # c1 port 4
          + u[0, 1, 1] * u[7, 0, 0] * u[3, 0, 1] * u[4, 0, 1]),  # c1 port 4
         u[7, 0, 1] * u[3, 0, 1] * u[4, 0, 1], 0],  # c1 ports 5-6

        [0, u[2, 1, 0] * u[4, 1, 0] * u[5, 0, 0], u[1, 0, 0] * u[2, 1, 1] * u[4, 1, 0] * u[5, 0, 0]  # 0 ports 0-2 ..
         + u[1, 1, 0] * u[3, 0, 0] * u[4, 1, 1] * u[5, 0, 0]  # 0 port 2 ...
         + u[1, 1, 0] * u[3, 1, 0] * u[7, 0, 0] * u[5, 0, 1],  # 0 port 2
         u[0, 0, 0] * (u[1, 0, 1] * u[2, 1, 1] * u[4, 1, 0] * u[5, 0, 0]  # 0 port 3 ...
                       + u[1, 1, 1] * u[3, 0, 0] * u[4, 1, 1] * u[5, 0, 0]  # 0 port 3 ...
                       + u[1, 1, 1] * u[3, 1, 0] * u[7, 0, 0] * u[5, 0, 1])  # 0 port 3 ...
         + u[0, 1, 0] * (u[6, 0, 0] * u[3, 0, 1] * u[4, 1, 1] * u[5, 0, 0]  # 0 port 3 ...
                         + u[6, 0, 0] * u[3, 1, 1] * u[7, 0, 0] * u[5, 0, 1]  # 0 port 3 ...
                         + u[6, 1, 0] * u[9, 0, 0] * u[7, 0, 1] * u[5, 0, 1]),  # 0 port 3
         u[0, 1, 0] * (u[1, 0, 1] * u[2, 1, 1] * u[4, 1, 0] * u[5, 0, 0]  # 0 port 4 ...
                       + u[1, 1, 1] * u[3, 0, 0] * u[4, 1, 1] * u[5, 0, 0]  # 0 port 4 ...
                       + u[1, 1, 1] * u[3, 1, 0] * u[7, 0, 0] * u[5, 0, 1])  # 0 port 4 ...
         + u[0, 1, 1] * (u[6, 0, 0] * u[3, 0, 1] * u[4, 1, 1] * u[5, 0, 0]  # 0 port 4 ...
                         + u[6, 0, 0] * u[3, 1, 1] * u[7, 0, 0] * u[5, 0, 1]  # 0 port 4 ...
                         + u[6, 1, 0] * u[9, 0, 0] * u[7, 0, 1] * u[5, 0, 1]),  # 0 port 4
         u[6, 0, 1] * (u[3, 0, 1] * u[4, 1, 1] * u[5, 0, 0] + u[3, 1, 1] * u[7, 0, 0] * u[5, 0, 1])  # 0 port 5 ...
         + u[6, 1, 1] * u[9, 0, 0] * u[7, 0, 1] * u[5, 0, 1], u[9, 0, 1] * u[7, 0, 1] * u[5, 0, 1]],  # 0 ports 5-6

        [0, u[2, 1, 0] * u[4, 1, 0] * u[5, 1, 0] * u[8, 0, 0],  # t0 ports 0-1
         u[1, 0, 0] * u[2, 1, 1] * u[4, 1, 0] * u[5, 1, 0] * u[8, 0, 0]  # t0 port 2 ...
         + u[1, 1, 0] *  # t0 port 2 ...
         (u[3, 0, 0] * u[4, 1, 1] * u[5, 1, 0] * u[8, 0, 0]  # t0 port 2 ...
          + u[3, 1, 0] * u[7, 0, 0] * u[5, 1, 1] * u[8, 0, 0]  # t0 port 2...
          + u[3, 1, 0] * u[7, 1, 0] * u[10, 0, 0] * u[8, 0, 1]),  # t0 port 2
         u[0, 0, 0] * (u[1, 0, 1] * u[2, 1, 1] * u[4, 1, 0] * u[5, 1, 0] * u[8, 0, 0]  # t0 port 3 ...
                       + u[1, 1, 1] * (u[3, 0, 0] * u[4, 1, 1] * u[5, 1, 0] * u[8, 0, 0]  # t0 port 3 ...
                                       + u[3, 1, 0] * u[7, 0, 0] * u[5, 1, 1] * u[8, 0, 0]  # t0 port 3 ...
                                       + u[3, 1, 0] * u[7, 1, 0] * u[10, 0, 0] * u[8, 0, 1]))  # t0 port 3 ...
         + u[0, 1, 0] * (u[6, 0, 0] * (u[3, 0, 1] * u[4, 1, 1] * u[5, 1, 0] * u[8, 0, 0]  # t0 port 3 ...
                                       + u[3, 1, 1] * u[7, 0, 0] * u[5, 1, 1] * u[8, 0, 0]  # t0 port 3 ...
                                       + u[3, 1, 1] * u[7, 1, 0] * u[10, 0, 0] * u[8, 0, 1])  # t0 port 3 ...
                         + u[6, 1, 0] * (u[9, 0, 0] * u[7, 0, 1] * u[5, 1, 1] * u[8, 0, 0]  # t0 port 3 ...
                                         + u[9, 0, 0] * u[7, 1, 1] * u[10, 0, 0] * u[8, 0, 1]  # t0 port 3 ...
                                         + u[9, 1, 0] * u[10, 0, 1] * u[8, 0, 1])),  # t0 port 3
         u[0, 0, 1] * (u[1, 0, 1] * u[2, 1, 1] * u[4, 1, 0] * u[5, 1, 0] * u[8, 0, 0]  # t0 port 4 ...
                       + u[1, 1, 1] * (u[3, 0, 0] * u[4, 1, 1] * u[5, 1, 0] * u[8, 0, 0]  # t0 port 4 ...
                                       + u[3, 1, 0] * u[7, 0, 0] * u[5, 1, 1] * u[8, 0, 0]  # t0 port 4 ...
                                       + u[3, 1, 0] * u[7, 1, 0] * u[10, 0, 0] * u[8, 0, 1]))  # t0 port 4 ...
         + u[0, 1, 1] * (u[6, 0, 0] * (u[3, 0, 1] * u[4, 1, 1] * u[5, 1, 0] * u[8, 0, 0]  # t0 port 4 ...
                                       + u[3, 1, 1] * u[7, 0, 0] * u[5, 1, 1] * u[8, 0, 0]  # t0 port 4 ...
                                       + u[3, 1, 1] * u[7, 1, 0] * u[10, 0, 0] * u[8, 0, 1])  # t0 port 4 ...
                         + u[6, 1, 0] * (u[9, 0, 0] * u[7, 0, 1] * u[5, 1, 1] * u[8, 0, 0]  # t0 port 4 ...
                                         + u[9, 0, 0] * u[7, 1, 1] * u[10, 0, 0] * u[8, 0, 1]  # t0 port 4 ...
                                         + u[9, 1, 0] * u[10, 0, 1] * u[8, 0, 1])),  # t0 port 4
         u[6, 0, 1] * (u[3, 0, 1] * u[4, 1, 1] * u[5, 1, 0] * u[8, 0, 0]  # t0 port 5 ...
                       + u[3, 1, 1] * u[7, 0, 0] * u[5, 1, 1] * u[8, 0, 0]  # t0 port 5 ...
                       + u[3, 1, 1] * u[7, 1, 0] * u[10, 0, 0] * u[8, 0, 1])  # t0 port 5 ...
         + u[6, 1, 1] * (u[9, 0, 0] * u[7, 0, 1] * u[5, 1, 1] * u[8, 0, 0]  # t0 port 5 ...
                         + u[9, 0, 0] * u[7, 1, 1] * u[10, 0, 0] * u[8, 0, 1]  # t0 port 5 ...
                         + u[9, 1, 0] * u[10, 0, 1] * u[8, 0, 1]),  # t0 port 5
         + u[9, 0, 1] * u[7, 0, 1] * u[5, 1, 1] * u[8, 0, 0]  # t0 port 6 ...
         + u[9, 0, 1] * u[7, 1, 1] * u[10, 0, 0] * u[8, 0, 1]  # t0 port 6 ...
         + u[9, 1, 1] * u[10, 0, 1] * u[8, 0, 1]],  # t0 port 6

        [0, u[2, 1, 0] * u[4, 1, 0] * u[5, 1, 0] * u[8, 1, 0],  # t1 ports 0-1
         u[1, 0, 0] * u[2, 1, 1] * u[4, 1, 0] * u[5, 1, 0] * u[8, 1, 0]  # t1 port 2 ...
         + u[1, 1, 0] * u[3, 0, 0] * u[4, 1, 1] * u[5, 1, 0] * u[8, 1, 0]  # t1 port 2 ...
         + u[1, 1, 0] * u[3, 1, 0] * u[7, 0, 0] * u[5, 1, 1] * u[8, 1, 0]  # t1 port 2 ...
         + u[1, 1, 0] * u[3, 1, 0] * u[7, 1, 0] * u[10, 0, 0] * u[8, 1, 1],  # t1 port 2
         u[0, 0, 0] * (u[1, 0, 1] * u[2, 1, 1] * u[4, 1, 0] * u[5, 1, 0] * u[8, 1, 0]  # t0 port 3 ...
                       + u[1, 1, 1] * u[3, 0, 0] * u[4, 1, 1] * u[5, 1, 0] * u[8, 1, 0]  # t1 port 3 ...
                       + u[1, 1, 1] * u[3, 1, 0] * u[7, 0, 0] * u[5, 1, 1] * u[8, 1, 0]  # t1 port 3 ...
                       + u[1, 1, 1] * u[3, 1, 0] * u[7, 1, 0] * u[10, 0, 0] * u[8, 1, 1])  # t1 port 3 ...
         + u[0, 1, 0] * (u[6, 0, 0] * (u[3, 0, 1] * u[4, 1, 1] * u[5, 1, 0] * u[8, 1, 0]  # t1 port 3 ...
                                       + u[3, 1, 1] * u[7, 0, 0] * u[5, 1, 1] * u[8, 1, 0]  # t1 port 3 ...
                                       + u[3, 1, 1] * u[7, 1, 0] * u[10, 0, 0] * u[8, 1, 1])  # t1 port 3 ...
                         + u[6, 1, 0] * (u[9, 0, 0] * u[7, 0, 1] * u[5, 1, 1] * u[8, 1, 0]  # t1 port 3 ...
                                         + u[9, 0, 0] * u[7, 1, 1] * u[10, 0, 0] * u[8, 1, 1]  # t1 port 3 ...
                                         + u[9, 1, 0] * u[10, 0, 1] * u[8, 1, 1])),  # t1 port 3
         u[0, 0, 1] * (u[1, 0, 1] * u[2, 1, 1] * u[4, 1, 0] * u[5, 1, 0] * u[8, 1, 0]  # t1 port 4 ...
                       + u[1, 1, 1] * u[3, 0, 0] * u[4, 1, 1] * u[5, 1, 0] * u[8, 1, 0]  # t1 port 4 ...
                       + u[1, 1, 1] * u[3, 1, 0] * u[7, 0, 0] * u[5, 1, 1] * u[8, 1, 0]  # t1 port 4 ...
                       + u[1, 1, 1] * u[3, 1, 0] * u[7, 1, 0] * u[10, 0, 0] * u[8, 1, 1])  # t1 port 4 ...
         + u[0, 1, 1] * (u[6, 0, 0] * (u[3, 0, 1] * u[4, 1, 1] * u[5, 1, 0] * u[8, 1, 0]  # t1 port 4 ...
                                       + u[3, 1, 1] * u[7, 0, 0] * u[5, 1, 1] * u[8, 1, 0]  # t1 port 4 ...
                                       + u[3, 1, 1] * u[7, 1, 0] * u[10, 0, 0] * u[8, 1, 1])  # t1 port 4 ...
                         + u[6, 1, 0] * (u[9, 0, 0] * u[7, 0, 1] * u[5, 1, 1] * u[8, 1, 0]  # t1 port 4 ...
                                         + u[9, 0, 0] * u[7, 1, 1] * u[10, 0, 0] * u[8, 1, 1]  # t1 port 4 ...
                                         + u[9, 1, 0] * u[10, 0, 1] * u[8, 1, 1])),  # t1 port 4
         u[6, 1, 1] * (u[9, 0, 0] * u[7, 0, 1] * u[5, 1, 1] * u[8, 1, 0]
                       + u[9, 0, 0] * u[7, 1, 1] * u[10, 0, 0] * u[8, 1, 1]
                       + u[9, 1, 0] * u[10, 0, 1] * u[8, 1, 1]),
         u[9, 0, 1] * u[7, 0, 1] * u[5, 1, 1] * u[8, 1, 0]  # t1 port 5 ...
         + u[9, 0, 1] * u[7, 1, 1] * u[10, 0, 0] * u[8, 1, 1]  # t1 port 5 ...
         + u[9, 1, 1] * u[10, 0, 1] * u[8, 1, 1]],  # t1 port 5

        [0, 0, u[1, 1, 0] * u[3, 1, 0] * u[7, 1, 0] * u[10, 1, 0],  # a2 ports 0-2
         u[0, 0, 0] * u[1, 1, 1] * u[3, 1, 0] * u[7, 1, 0] * u[10, 1, 0]  # a2 port 3 ...
         + u[0, 1, 0] * (u[6, 0, 0] * u[3, 1, 1] * u[7, 1, 0] * u[10, 1, 0]  # a2 port 3 ...
                         + u[6, 1, 0] * u[9, 0, 0] * u[7, 1, 1] * u[10, 1, 0]  # a2 port 3 ...
                         + u[6, 1, 0] * u[9, 1, 0] * u[10, 1, 1]),  # a2 port 3
         u[0, 0, 1] * u[1, 1, 1] * u[3, 1, 0] * u[7, 1, 0] * u[10, 1, 0]  # a2 port 4 ...
         + u[0, 1, 1] * (u[6, 0, 0] * u[3, 1, 1] * u[7, 1, 0] * u[10, 1, 0]  # a2 port 4 ...
                         + u[6, 1, 0] * u[9, 0, 0] * u[7, 1, 1] * u[10, 1, 0]  # a2 port 4 ...
                         + u[6, 1, 0] * u[9, 1, 0] * u[10, 1, 1]),  # a2 port 4
         u[6, 0, 1] * u[3, 1, 1] * u[7, 1, 0] * u[10, 1, 0]  # a2 port 5 ...
         + u[6, 1, 1] * u[9, 0, 0] * u[7, 1, 1] * u[10, 1, 0]  # a2 port 5 ...
         + u[6, 1, 1] * u[9, 1, 0] * u[10, 1, 1],  # a2 port 5
         u[9, 0, 1] * u[7, 1, 1] * u[10, 1, 0] + u[9, 1, 1] * u[10, 1, 1]]])  # a2 port 6
    return gate


def get_heralded_gate_rate(rel_error=0, no_samples=1):
    """
        Compute the photon number probability distribution at the output of a photonic CNOT gate with ideal 4-photon inputs
        :param rel_error: relative error compared to the
        :param no_samples: number of samples to average for "expected" performance
        :return: mean probability amplitude for inputs (rows) translating to outputs (columns), e.g. M_21 ~ |01> -> |00>
        Meaning control qubit in state |0> and target qubit in state |1> initially
        """
    assert type(no_samples) == int and no_samples > 0, 'Please enter a positive integer number of samples'
    gate_basis = np.array(bosonic.fock.basis(4, 7))
    # ordering (c0t0, c0t1, c1t0, c1t1) for both input and output
    output_probs_agg = np.ndarray(shape=(no_samples, 4, 4), dtype=np.double)
    inputs = np.array([[1, 1, 0, 1, 0, 1, 0], [1, 1, 0, 0, 1, 1, 0], [0, 1, 1, 1, 0, 1, 0], [0, 1, 1, 0, 1, 1, 0]])
    input_indices = np.ndarray(shape=(4, 1), dtype=int)  # indices of gate_basis for the above inputs

    for x in range(np.size(inputs, 0)):
        input_indices[x] = np.where((gate_basis == inputs[x]).all(axis=1))
    for x in range(no_samples):
        cnot_gate = bosonic.aa_phi(np.array(imperfect_cnot_gate(rel_error), dtype=complex), 4)
        for y in range(np.size(input_indices)):
            hv_input = np.zeros(np.size(gate_basis, 0), dtype=complex)
            hv_input[input_indices[y]] = 1 + 0j
            hv_output = np.abs(cnot_gate.dot(hv_input)) ** 2
            output_probs_agg[x, y, :] = hv_output[input_indices].flatten()
    return np.mean(output_probs_agg, axis=0)


if __name__ == '__main__':
    rel_err = np.linspace(0.0, 0.35, 5)
    samples = 700
    output_arr = np.array([get_heralded_gate_rate(err, no_samples=samples, general=False) for err in rel_err])

    fig = plt.figure(figsize=(6, 6))
    ax = fig.add_subplot(111)
    ax.plot(np.arange(np.size(rel_err)) * 100, 1e3 * output_arr[:, 0, 0], 'b')

    ax.set_ylabel('Heralding CNOT Gate Rate (kHz)', fontsize=14, color='blue')
    ax.set_xlabel('Normalized Standard Error in MZI Reflectivities', fontsize=14)
    ax.grid('on')
    plt.show()
