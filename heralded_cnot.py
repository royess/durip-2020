import numpy as np
import bosonic
import matplotlib.pyplot as plt


def imperfect_cnot_gate(rel_error=0.01):
    r_ideal = np.sqrt([0, 0.227, 1 / 2, 1 / 2, 0.227, 1 / 2, 0.243, 1 / 2])
    r = [np.random.normal(loc=r_ideal[i], scale=rel_error * np.sqrt(r_ideal[i])) for i in range(len(r_ideal))]
    # TODO: Figure out why still getting some imaginary sqrt()'s in Jupyter NB (here, seems to be OK)
    for k in range(len(r)):
        if r[k] < 0 or r[k] >= 1:
            while r[k] < 0 or r[k] >= 1:
                r[k] = np.random.normal(loc=r_ideal[k], scale=rel_error * np.sqrt(r_ideal[k]))
            # print(r[k])
    t = np.sqrt([1 - r[i] ** 2 for i in range(len(r))])

    gate = np.array([[1, 0, 0, 0, 0, 0, 0],
                     # c0
                     [0, r[1], -r[2] * t[1], -r[3] * t[2] * t[1], t[3] * t[2] * t[1], 0, 0],
                     # |1>
                     [0, -t[1] * r[5], -r[2] * r[1] * r[5] - t[2] * r[4] * t[5],
                      -r[3] * t[2] * r[1] * r[5] + r[3] * r[2] * r[4] * t[5],
                      +t[3] * t[2] * r[1] * r[5] - t[3] * r[2] * r[4] * t[5], t[4] * t[5], 0],
                     # c1
                     [0, -t[1] * t[5] * t[6] * t[7],
                      r[2] * r[1] * t[5] * t[6] * t[7] - t[2] * r[4] * r[5] * t[6] * t[7],
                      -r[3] * r[2] * r[4] * r[5] * t[6] * t[7] - r[3] * t[2] * r[1] * t[5] * t[6] * t[7] + t[3] * r[7],
                      t[3] * t[2] * r[1] * t[5] * t[6] * t[7] + r[3] * r[7] + t[3] * r[2] * r[4] * r[5] * t[6] * t[7],
                      -t[4] * r[5] * t[6] * t[7], -r[6] * t[7]],
                     # t1
                     [0, t[1] * t[5] * t[6] * r[7], r[2] * r[1] * t[5] * t[6] * r[7] - t[2] * r[4] * r[5] * t[6] * r[7],
                      +r[3] * t[2] * r[1] * t[5] * t[6] * r[7] + r[3] * r[2] * r[4] * r[5] * t[6] * r[7] + t[3] * t[7],
                      -t[3] * t[2] * r[1] * t[5] * t[6] * r[7] - t[3] * r[2] * r[4] * r[5] * t[6] * r[7] + r[3] * t[7],
                      t[4] * r[5] * t[6] * r[7], r[6] * r[7]],
                     # t0
                     [0, 0, t[2] * t[4], -r[3] * r[2] * t[4], t[3] * r[2] * t[4], r[4], 0],
                     # |1>
                     [0, t[1] * t[5] * r[6], r[2] * r[1] * t[5] * r[6] - t[2] * r[4] * r[5] * r[6],
                      r[3] * r[2] * r[4] * r[5] * r[6] + r[3] * t[2] * r[1] * t[5] * r[6],
                      -t[3] * t[2] * r[1] * t[5] * r[6] - t[3] * r[2] * r[4] * r[5] * r[6],
                      t[4] * r[5] * r[6], -t[6]]])
    # |0>
    return gate


def mzi_unitary(phi=0):
    mzi_uni = np.matrix.getH(1 / 2 * np.array([[1, 1], [1, -1]]) @ np.array([[np.exp(1j * phi), 0], [0, 1]])
                             @ np.array([[1, 1], [1, -1]]))
    mzi_3_by_3 = np.zeros(shape=(3, 3), dtype=complex)
    mzi_3_by_3[1:, 1:] = mzi_uni
    return mzi_3_by_3


# TODO: Figure out what errors are causing significantly different results than 'imperfect_cnot_gate()'
def imperfect_cnot_gate_general(phase_error=0.0):
    # get reflectivity unitaries assuming a normal distribution for phase tuning error
    # used base-1 indexing (gasp!)
    phi_ideal = [0, np.pi / 2, np.pi / 2, -2.14838, 2.14838, np.pi / 2, 2.11064, 0, 0, np.pi / 2, 0, 0]
    phi_imperfect = [np.random.normal(loc=phase, scale=phase_error) for phase in phi_ideal]
    u = np.array([mzi_unitary(phi=phi_imp) for phi_imp in phi_imperfect])
    u[[1, 2, 5, 9], ] *= np.exp(-1j * np.pi / 4)
    u[[3, 4], ] *= np.exp(1j * -1.07419)
    u[[6], ] *= np.exp(1j * - 1.05532)
    gate = np.array([
        [1, 0, 0, 0, 0, 0, 0],  # c0 ports 1-7

        [0, u[3, 1, 1], u[2, 1, 1] * u[3, 1, 2], u[1, 1, 1] * u[2, 1, 2] * u[3, 1, 2],  # a1 ports 1-4
         u[1, 1, 2] * u[2, 1, 2] * u[3, 1, 2], 0, 0],  # a1 ports 5-7

        [0, u[3, 2, 1] * u[5, 1, 1],  # c1 ports 1-2
         u[2, 1, 1] * u[3, 2, 2] * u[5, 1, 1] + u[2, 2, 1] * u[4, 1, 1] * u[5, 1, 2],  # c1 port 3
         (u[1, 1, 1] * (u[2, 1, 2] * u[3, 2, 2] * u[5, 1, 1] + u[2, 2, 2] * u[4, 1, 1] * u[5, 1, 2])  # c1 port 4 ...
          + u[1, 2, 1] * u[7, 1, 1] * u[4, 1, 2] * u[5, 1, 2]),  # c1 port 4
         (u[1, 1, 2] * (u[2, 1, 2] * u[3, 2, 2] * u[5, 1, 1] + u[2, 2, 2] * u[4, 1, 1] * u[5, 1, 2])  # c1 port 5
          + u[1, 2, 2] * u[7, 1, 1] * u[4, 1, 2] * u[5, 1, 2]),  # c1 port 5
         u[7, 1, 2] * u[4, 1, 2] * u[5, 1, 2], 0],  # c1 ports 6-7

        [0, u[3, 2, 1] * u[5, 2, 1] * u[6, 1, 1], u[2, 1, 1] * u[3, 2, 2] * u[5, 2, 1] * u[6, 1, 1]  # 0 ports 1-3 ..
         + u[2, 2, 1] * u[4, 1, 1] * u[5, 2, 2] * u[6, 1, 1]  # 0 port 3 ...
         + u[2, 2, 1] * u[4, 2, 1] * u[8, 1, 1] * u[6, 1, 2],  # 0 port 3
         u[1, 1, 1] * (u[2, 1, 2] * u[3, 2, 2] * u[5, 2, 1] * u[6, 1, 1]  # 0 port 4 ...
                       + u[2, 2, 2] * u[4, 1, 1] * u[5, 2, 2] * u[6, 1, 1]  # 0 port 4 ...
                       + u[2, 2, 2] * u[4, 2, 1] * u[8, 1, 1] * u[6, 1, 2])  # 0 port 4 ...
         + u[1, 2, 1] * (u[7, 1, 1] * u[4, 1, 2] * u[5, 2, 2] * u[6, 1, 1]  # 0 port 4 ...
                         + u[7, 1, 1] * u[4, 2, 2] * u[8, 1, 1] * u[6, 1, 2]  # 0 port 4 ...
                         + u[7, 2, 1] * u[10, 1, 1] * u[8, 1, 2] * u[6, 1, 2]),  # 0 port 4
         u[1, 2, 1] * (u[2, 1, 2] * u[3, 2, 2] * u[5, 2, 1] * u[6, 1, 1]  # 0 port 5 ...
                       + u[2, 2, 2] * u[4, 1, 1] * u[5, 2, 2] * u[6, 1, 1]  # 0 port 5 ...
                       + u[2, 2, 2] * u[4, 2, 1] * u[8, 1, 1] * u[6, 1, 2])  # 0 port 5 ...
         + u[1, 2, 2] * (u[7, 1, 1] * u[4, 1, 2] * u[5, 2, 2] * u[6, 1, 1]  # 0 port 5 ...
                         + u[7, 1, 1] * u[4, 2, 2] * u[8, 1, 1] * u[6, 1, 2]  # 0 port 5 ...
                         + u[7, 2, 1] * u[10, 1, 1] * u[8, 1, 2] * u[6, 1, 2]),  # 0 port 5
         u[7, 1, 2] * (u[4, 1, 2] * u[5, 2, 2] * u[6, 1, 1] + u[4, 2, 2] * u[8, 1, 1] * u[6, 1, 2])  # 0 port 6 ...
         + u[7, 2, 2] * u[10, 1, 1] * u[8, 1, 2] * u[6, 1, 2], u[10, 1, 2] * u[8, 1, 2] * u[6, 1, 2]],  # 0 ports 6-7

        [0, u[3, 2, 1] * u[5, 2, 1] * u[6, 2, 1] * u[9, 1, 1],  # t0 ports 1-2
         u[2, 1, 1] * u[3, 2, 2] * u[5, 2, 1] * u[6, 2, 1] * u[9, 1, 1]  # t0 port 3 ...
         + u[2, 2, 1] *  # t0 port 3 ...
         (u[4, 1, 1] * u[5, 2, 2] * u[6, 2, 1] * u[9, 1, 1]  # t0 port 3 ...
          + u[4, 2, 1] * u[8, 1, 1] * u[6, 2, 2] * u[9, 1, 1]  # t0 port 3...
          + u[4, 2, 1] * u[8, 2, 1] * u[11, 1, 1] * u[9, 1, 2]),  # t0 port 3
         u[1, 1, 1] * (u[2, 1, 2] * u[3, 2, 2] * u[5, 2, 1] * u[6, 2, 1] * u[9, 1, 1]  # t0 port 4 ...
                       + u[2, 2, 2] * (u[4, 1, 1] * u[5, 2, 2] * u[6, 2, 1] * u[9, 1, 1]  # t0 port 4 ...
                                       + u[4, 2, 1] * u[8, 1, 1] * u[6, 2, 2] * u[9, 1, 1]  # t0 port 4 ...
                                       + u[4, 2, 1] * u[8, 2, 1] * u[11, 1, 1] * u[9, 1, 2]))  # t0 port 4 ...
         + u[1, 2, 1] * (u[7, 1, 1] * (u[4, 1, 2] * u[5, 2, 2] * u[6, 2, 1] * u[9, 1, 1]  # t0 port 4 ...
                                       + u[4, 2, 2] * u[8, 1, 1] * u[6, 2, 2] * u[9, 1, 1]  # t0 port 4 ...
                                       + u[4, 2, 2] * u[8, 2, 1] * u[11, 1, 1] * u[9, 1, 2])  # t0 port 4 ...
                         + u[7, 2, 1] * (u[10, 1, 1] * u[8, 1, 2] * u[6, 2, 2] * u[9, 1, 1]  # t0 port 4 ...
                                         + u[10, 1, 1] * u[8, 2, 2] * u[11, 1, 1] * u[9, 1, 2]  # t0 port 4 ...
                                         + u[10, 2, 1] * u[11, 1, 2] * u[9, 1, 2])),  # t0 port 4
         u[1, 1, 2] * (u[2, 1, 2] * u[3, 2, 2] * u[5, 2, 1] * u[6, 2, 1] * u[9, 1, 1]  # t0 port 5 ...
                       + u[2, 2, 2] * (u[4, 1, 1] * u[5, 2, 2] * u[6, 2, 1] * u[9, 1, 1]  # t0 port 5 ...
                                       + u[4, 2, 1] * u[8, 1, 1] * u[6, 2, 2] * u[9, 1, 1]  # t0 port 5 ...
                                       + u[4, 2, 1] * u[8, 2, 1] * u[11, 1, 1] * u[9, 1, 2]))  # t0 port 5 ...
         + u[1, 2, 2] * (u[7, 1, 1] * (u[4, 1, 2] * u[5, 2, 2] * u[6, 2, 1] * u[9, 1, 1]  # t0 port 5 ...
                                       + u[4, 2, 2] * u[8, 1, 1] * u[6, 2, 2] * u[9, 1, 1]  # t0 port 5 ...
                                       + u[4, 2, 2] * u[8, 2, 1] * u[11, 1, 1] * u[9, 1, 2])  # t0 port 5 ...
                         + u[7, 2, 1] * (u[10, 1, 1] * u[8, 1, 2] * u[6, 2, 2] * u[9, 1, 1]  # t0 port 5 ...
                                         + u[10, 1, 1] * u[8, 2, 2] * u[11, 1, 1] * u[9, 1, 2]  # t0 port 5 ...
                                         + u[10, 2, 1] * u[11, 1, 2] * u[9, 1, 2])),  # t0 port 5
         u[7, 1, 2] * (u[4, 1, 2] * u[5, 2, 2] * u[6, 2, 1] * u[9, 1, 1]  # t0 port 6 ...
                       + u[4, 2, 2] * u[8, 1, 1] * u[6, 2, 2] * u[9, 1, 1]  # t0 port 6 ...
                       + u[4, 2, 2] * u[8, 2, 1] * u[11, 1, 1] * u[9, 1, 2])  # t0 port 6 ...
         + u[7, 2, 2] * (u[10, 1, 1] * u[8, 1, 2] * u[6, 2, 2] * u[9, 1, 1]  # t0 port 6 ...
                         + u[10, 1, 1] * u[8, 2, 2] * u[11, 1, 1] * u[9, 1, 2]  # t0 port 6 ...
                         + u[10, 2, 1] * u[11, 1, 2] * u[9, 1, 2]),  # t0 port 6
         + u[10, 1, 2] * u[8, 1, 2] * u[6, 2, 2] * u[9, 1, 1]  # t0 port 7 ...
         + u[10, 1, 2] * u[8, 2, 2] * u[11, 1, 1] * u[9, 1, 2]  # t0 port 7 ...
         + u[10, 2, 2] * u[11, 1, 2] * u[9, 1, 2]],  # t0 port 7

        [0, u[3, 2, 1] * u[5, 2, 1] * u[6, 2, 1] * u[9, 2, 1],  # t1 ports 1-2
         u[2, 1, 1] * u[3, 2, 2] * u[5, 2, 1] * u[6, 2, 1] * u[9, 2, 1]  # t1 port 3 ...
         + u[2, 2, 1] * u[4, 1, 1] * u[5, 2, 2] * u[6, 2, 1] * u[9, 2, 1]  # t1 port 3 ...
         + u[2, 2, 1] * u[4, 2, 1] * u[8, 1, 1] * u[6, 2, 2] * u[9, 2, 1]  # t1 port 3 ...
         + u[2, 2, 1] * u[4, 2, 1] * u[8, 2, 1] * u[11, 1, 1] * u[9, 2, 2],  # t1 port 3
         u[1, 1, 1] * (u[2, 1, 2] * u[3, 2, 2] * u[5, 2, 1] * u[6, 2, 1] * u[9, 2, 1]  # t0 port 4 ...
                       + u[2, 2, 2] * u[4, 1, 1] * u[5, 2, 2] * u[6, 2, 1] * u[9, 2, 1]  # t1 port 4 ...
                       + u[2, 2, 2] * u[4, 2, 1] * u[8, 1, 1] * u[6, 2, 2] * u[9, 2, 1]  # t1 port 4 ...
                       + u[2, 2, 2] * u[4, 2, 1] * u[8, 2, 1] * u[11, 1, 1] * u[9, 2, 2])  # t1 port 4 ...
         + u[1, 2, 1] * (u[7, 1, 1] * (u[4, 1, 2] * u[5, 2, 2] * u[6, 2, 1] * u[9, 2, 1]  # t1 port 4 ...
                                       + u[4, 2, 2] * u[8, 1, 1] * u[6, 2, 2] * u[9, 2, 1]  # t1 port 4 ...
                                       + u[4, 2, 2] * u[8, 2, 1] * u[11, 1, 1] * u[9, 2, 2])  # t1 port 4 ...
                         + u[7, 2, 1] * (u[10, 1, 1] * u[8, 1, 2] * u[6, 2, 2] * u[9, 2, 1]  # t1 port 4 ...
                                         + u[10, 1, 1] * u[8, 2, 2] * u[11, 1, 1] * u[9, 2, 2]  # t1 port 4 ...
                                         + u[10, 2, 1] * u[11, 1, 2] * u[9, 2, 2])),  # t1 port 4
         u[1, 1, 2] * (u[2, 1, 2] * u[3, 2, 2] * u[5, 2, 1] * u[6, 2, 1] * u[9, 2, 1]  # t1 port 5 ...
                       + u[2, 2, 2] * u[4, 1, 1] * u[5, 2, 2] * u[6, 2, 1] * u[9, 2, 1]  # t1 port 5 ...
                       + u[2, 2, 2] * u[4, 2, 1] * u[8, 1, 1] * u[6, 2, 2] * u[9, 2, 1]  # t1 port 5 ...
                       + u[2, 2, 2] * u[4, 2, 1] * u[8, 2, 1] * u[11, 1, 1] * u[9, 2, 2])  # t1 port 5 ...
         + u[1, 2, 2] * (u[7, 1, 1] * (u[4, 1, 2] * u[5, 2, 2] * u[6, 2, 1] * u[9, 2, 1]  # t1 port 5 ...
                                       + u[4, 2, 2] * u[8, 1, 1] * u[6, 2, 2] * u[9, 2, 1]  # t1 port 5 ...
                                       + u[4, 2, 2] * u[8, 2, 1] * u[11, 1, 1] * u[9, 2, 2])  # t1 port 5 ...
                         + u[7, 2, 1] * (u[10, 1, 1] * u[8, 1, 2] * u[6, 2, 2] * u[9, 2, 1]  # t1 port 5 ...
                                         + u[10, 1, 1] * u[8, 2, 2] * u[11, 1, 1] * u[9, 2, 2]  # t1 port 5 ...
                                         + u[10, 2, 1] * u[11, 1, 2] * u[9, 2, 2])),  # t1 port 5
         u[7, 2, 2] * (u[10, 1, 1] * u[8, 1, 2] * u[6, 2, 2] * u[9, 2, 1]
                       + u[10, 1, 1] * u[8, 2, 2] * u[11, 1, 1] * u[9, 2, 2]
                       + u[10, 2, 1] * u[11, 1, 2] * u[9, 2, 2]),
         u[10, 1, 2] * u[8, 1, 2] * u[6, 2, 2] * u[9, 2, 1]  # t1 port 6 ...
         + u[10, 1, 2] * u[8, 2, 2] * u[11, 1, 1] * u[9, 2, 2]  # t1 port 6 ...
         + u[10, 2, 2] * u[11, 1, 2] * u[9, 2, 2]],  # t1 port 6

        [0, 0, u[2, 2, 1] * u[4, 2, 1] * u[8, 2, 1] * u[11, 2, 1],  # a2 ports 1-3
         u[1, 1, 1] * u[2, 2, 2] * u[4, 2, 1] * u[8, 2, 1] * u[11, 2, 1]  # a2 port 4 ...
         + u[1, 2, 1] * (u[7, 1, 1] * u[4, 2, 2] * u[8, 2, 1] * u[11, 2, 1]  # a2 port 4 ...
                         + u[7, 2, 1] * u[10, 1, 1] * u[8, 2, 2] * u[11, 2, 1]  # a2 port 4 ...
                         + u[7, 2, 1] * u[10, 2, 1] * u[11, 2, 2]),  # a2 port 4
         u[1, 1, 2] * u[2, 2, 2] * u[4, 2, 1] * u[8, 2, 1] * u[11, 2, 1]  # a2 port 5 ...
         + u[1, 2, 2] * (u[7, 1, 1] * u[4, 2, 2] * u[8, 2, 1] * u[11, 2, 1]  # a2 port 5 ...
                         + u[7, 2, 1] * u[10, 1, 1] * u[8, 2, 2] * u[11, 2, 1]  # a2 port 5 ...
                         + u[7, 2, 1] * u[10, 2, 1] * u[11, 2, 2]),  # a2 port 5
         u[7, 1, 2] * u[4, 2, 2] * u[8, 2, 1] * u[11, 2, 1]  # a2 port 6 ...
         + u[7, 2, 2] * u[10, 1, 1] * u[8, 2, 2] * u[11, 2, 1]  # a2 port 6 ...
         + u[7, 2, 2] * u[10, 2, 1] * u[11, 2, 2],  # a2 port 6
         u[10, 1, 2] * u[8, 2, 2] * u[11, 2, 1] + u[10, 2, 2] * u[11, 2, 2]]])  # a2 port 7
    return gate


def get_heralded_gate_rate(rel_error=0, nsamples=1):
    assert type(nsamples)==int and nsamples > 0, 'Please enter a positive integer number of samples'
    gate_basis = np.array(bosonic.fock.basis(4, 7))
    output_probs_agg = np.ndarray(shape=(nsamples,4,4),dtype=np.double)
    for x in range(nsamples):
        gatey_b = bosonic.aa_phi(np.array(imperfect_cnot_gate(rel_error), dtype=complex), 4)
        desired_inputs = np.array([[1,1,0,1,0,1,0], [1,1,0,0,1,1,0],[0,1,1,1,0,1,0],[0,1,1,0,1,1,0]])
        # c0t0, c0t1, c1t0, c1t1
        input_indices = np.ndarray(shape=(4, 1), dtype=int) # indices of the large gate basis above

        for y in range(np.size(desired_inputs, 0)):
            input_indices[y] = np.where((gate_basis == desired_inputs[y]).all(axis=1))

        for y in range(np.size(input_indices)):
            hv_input = np.zeros(np.size(gate_basis, 0), dtype=complex)
            hv_input[input_indices[y]] = 1 + 0j
            hv_output = np.abs(gatey_b.dot(hv_input))**2
            output_probs_agg[x, y, :] = hv_output[input_indices].flatten()
    return np.mean(output_probs_agg, axis=0)


if __name__ == '__main__':
    rel_err = np.linspace(0.0, 10 * 0.035, 30)
    samples = 700
    output_arr = np.array([get_heralded_gate_rate(err, nsamples=samples) for err in rel_err])

    fig = plt.figure(figsize=(6, 6))
    ax = fig.add_subplot(111)
    ax.plot(np.arange(np.size(rel_err))*10, 1e3 * output_arr[:, 0, 0], 'b')
    # ax.set_yticks()
    ax.set_ylabel('Heralding CNOT Gate Rate (kHz)', fontsize=14, color='blue')
    ax.set_xlabel('Multiples of Expected Standard Error in MZI Reflectivities', fontsize=14)
    ax.grid('on')
    plt.show()
